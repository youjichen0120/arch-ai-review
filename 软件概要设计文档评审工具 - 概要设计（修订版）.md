# 软件概要设计文档评审工具 - 概要设计（修订版）

## 1. 项目概述

### 1.1 项目背景
在软件开发过程中，概要设计文档的质量直接影响后续开发工作的效率和最终产品的质量。传统的人工评审方式存在效率低、标准不统一、主观性强等问题。本项目旨在借助大模型的能力，开发一个智能化的软件概要设计文档评审工具，提升评审效率和质量。

### 1.2 项目目标
- 实现文档格式的自动化检查和规范化
- 提供基于大模型的智能内容分析和评审建议
- 建立完整的评审流程管理和结果跟踪机制
- 提供友好的用户界面和便捷的操作体验

### 1.3 技术架构
- **前端**：Vue.js 3.x + Element Plus
- **后端**：Java 17 + Spring Boot 3.5.x + Spring AI
- **数据库**：MySQL 8.0
- **AI集成**：通义千问 API（通过Spring AI集成）
- **文档处理**：Apache POI (Word文档解析)

## 2. 功能需求分析

### 2.1 核心功能模块

#### 2.1.1 文档解析模块
- **功能描述**：支持Word文档(.docx)和PDF的解析和内容提取
- **技术要求**：
  - 支持文本内容、格式信息、图表、表格的提取
  - 解析准确率 ≥ 95%
  - 单文档解析时间 ≤ 10秒
  - 支持最大50MB的文档文件

#### 2.1.2 格式检查模块
- **功能描述**：检查文档格式是否符合规范要求
- **检查项目**：
  - 标题层级结构规范性
  - 图表编号连续性
  - 页面格式统一性
  - 字体、段落格式一致性
- **技术要求**：
  - 检查规则可配置
  - 支持自定义格式规范
  - 检查结果详细记录

#### 2.1.3 内容评审模块
- **功能描述**：基于大模型对文档内容进行智能分析
- **评审维度**：
  - 设计合理性分析
  - 内容完整性检查
  - 逻辑一致性验证
  - 技术方案可行性评估
- **技术要求**：
  - 集成通义千问或其他大模型API
  - 支持中文文档分析
  - 评审结果结构化输出

#### 2.1.4 问题管理模块
- **功能描述**：对发现的问题进行管理和跟踪
- **功能特性**：
  - 问题分类和严重程度标记
  - 问题位置精确定位
  - 改进建议自动生成
  - 问题状态跟踪

#### 2.1.5 评审报告模块
- **功能描述**：生成结构化的评审报告
- **报告内容**：
  - 评审总结和总体评价
  - 问题清单和详细说明
  - 改进建议和最佳实践
  - 评审通过/不通过结论

#### 2.1.6 人工复核模块
- **功能描述**：支持人工对AI评审结果进行复核
- **功能特性**：
  - 复核状态管理
  - 复核意见录入
  - 复核结果确认
  - 复核历史记录

#### 2.1.7 数据管理模块
- **功能描述**：评审数据的存储和管理
- **功能特性**：
  - 评审历史查询
  - 数据统计分析
  - 报告导出功能
  - 数据备份和恢复

### 2.2 非功能需求

#### 2.2.1 性能需求
- 支持10个用户同时在线使用
- 单文档处理响应时间 ≤ 30秒
- 系统可用性 ≥ 99%
- 数据库查询响应时间 ≤ 2秒

#### 2.2.2 安全需求
- 用户身份认证和权限控制
- 数据传输加密(HTTPS)
- 敏感数据存储加密
- 操作日志记录和审计

#### 2.2.3 易用性需求
- 界面简洁直观，操作流程清晰
- 支持拖拽上传文档
- 提供操作指导和帮助文档
- 支持移动端访问

## 3. 系统架构设计

### 3.1 前后端分离架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端层        │    │   后端层        │    │   数据层        │
│   (Vue.js)      │    │  (Spring Boot)  │    │   (MySQL)       │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • 用户界面      │    │ • RESTful API   │    │ • 用户数据      │
│ • 文档上传      │◄──►│ • 业务逻辑      │◄──►│ • 文档信息      │
│ • 结果展示      │    │ • Spring AI     │    │ • 评审结果      │
│ • 复核操作      │    │ • 权限控制      │    │ • 系统配置      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 3.2 技术架构

#### 3.2.1 前端架构
- **框架**：Vue.js 3.x + Composition API
- **UI组件库**：Element Plus
- **状态管理**：Pinia
- **路由管理**：Vue Router 4.x
- **HTTP客户端**：Axios
- **构建工具**：Vite

#### 3.2.2 后端架构
- **框架**：Spring Boot 3.5.x
- **AI集成**：Spring AI
- **安全框架**：Spring Security
- **数据访问**：MyBatis Plus
- **文档处理**：Apache POI + Apache PDFBox
- **缓存**：Redis

#### 3.2.3 数据库设计
- **数据库**：MySQL 8.0
- **字符集**：utf8mb4
- **存储引擎**：InnoDB
- **连接池**：HikariCP

### 3.3 数据库设计

#### 3.3.1 用户表 (users)
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100),
    role ENUM('ADMIN', 'REVIEWER', 'USER') DEFAULT 'USER',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);
```

#### 3.3.2 文档表 (documents)
```sql
CREATE TABLE documents (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    filename VARCHAR(255) NOT NULL,
    original_filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    file_type VARCHAR(10) NOT NULL,
    status ENUM('UPLOADING', 'PARSING', 'PARSED', 'REVIEWING', 'COMPLETED', 'FAILED') DEFAULT 'UPLOADING',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

#### 3.3.3 评审结果表 (review_results)
```sql
CREATE TABLE review_results (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    document_id BIGINT NOT NULL,
    overall_score DECIMAL(3,2),
    overall_status ENUM('PASS', 'FAIL', 'NEED_REVIEW') NOT NULL,
    format_score DECIMAL(3,2),
    content_score DECIMAL(3,2),
    ai_review_summary TEXT,
    manual_review_required BOOLEAN DEFAULT FALSE,
    manual_review_notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (document_id) REFERENCES documents(id)
);
```

#### 3.3.4 问题表 (issues)
```sql
CREATE TABLE issues (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    review_result_id BIGINT NOT NULL,
    issue_type ENUM('FORMAT', 'CONTENT', 'LOGIC', 'COMPLETENESS') NOT NULL,
    severity ENUM('HIGH', 'MEDIUM', 'LOW') NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    suggestion TEXT,
    page_number INT,
    line_number INT,
    status ENUM('OPEN', 'RESOLVED', 'IGNORED') DEFAULT 'OPEN',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (review_result_id) REFERENCES review_results(id)
);
```

## 4. API接口设计

### 4.1 接口规范
- **协议**：HTTPS
- **数据格式**：JSON
- **认证方式**：JWT Token
- **跨域支持**：支持CORS跨域请求
- **版本控制**：/api/v1/

### 4.2 核心接口

#### 4.2.1 用户认证接口
```http
POST /api/v1/auth/login
Content-Type: application/json

{
    "username": "admin",
    "password": "password123"
}

Response:
{
    "code": 200,
    "message": "登录成功",
    "data": {
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "refreshToken": "refresh_token_here",
        "expiresAt": "2024-12-31T23:59:59Z",
        "user": {
            "id": 1,
            "username": "admin",
            "email": "admin@example.com",
            "role": "ADMIN",
            "permissions": ["document:upload", "document:review", "user:manage"]
        }
    }
}
```

#### 4.2.2 文档上传接口
```http
POST /api/v1/documents/upload
Authorization: Bearer {token}
Content-Type: multipart/form-data

FormData:
- file: (binary file data)

Response:
{
    "code": 200,
    "message": "文档上传成功",
    "data": {
        "documentId": 123,
        "filename": "design_doc.docx",
        "fileType": "docx",
        "fileSize": 2048576,
        "status": "UPLOADING"
    }
}
```

#### 4.2.3 开始评审接口
```http
POST /api/v1/reviews/start
Authorization: Bearer {token}
Content-Type: application/json

{
    "documentId": 123,
    "reviewType": "FULL"
}

Response:
{
    "code": 200,
    "message": "评审已开始",
    "data": {
        "reviewId": 456,
        "status": "REVIEWING",
        "estimatedTime": "30秒"
    }
}
```

#### 4.2.4 获取评审结果接口
```http
GET /api/v1/reviews/{reviewId}
Authorization: Bearer {token}

Response:
{
    "code": 200,
    "message": "获取成功",
    "data": {
        "reviewId": 456,
        "documentId": 123,
        "status": "COMPLETED",
        "overallScore": 85.5,
        "overallStatus": "PASS",
        "formatScore": 90.0,
        "contentScore": 81.0,
        "aiReviewSummary": "文档整体结构合理，内容较为完整...",
        "manualReviewRequired": false,
        "issues": [
            {
                "id": 1,
                "type": "CONTENT",
                "severity": "MEDIUM",
                "title": "缺少性能指标说明",
                "description": "在系统架构设计中未明确说明性能指标要求",
                "suggestion": "建议在系统架构章节中补充性能指标说明",
                "pageNumber": 15,
                "lineNumber": 3
            }
        ],
        "statistics": {
            "totalIssues": 5,
            "highSeverityIssues": 1,
            "mediumSeverityIssues": 3,
            "lowSeverityIssues": 1
        },
        "createdAt": "2024-01-15T10:30:00Z",
        "completedAt": "2024-01-15T10:32:30Z"
    }
}
```

## 5. Spring AI集成设计

### 5.1 Spring AI概述
Spring AI是Spring生态系统中的AI集成框架，提供了统一的API来集成各种AI服务提供商，包括OpenAI、Azure OpenAI、通义千问等。通过Spring AI，我们可以：

- 统一管理不同AI提供商的配置
- 提供标准化的AI服务调用接口
- 支持AI服务的降级和容错
- 简化AI集成的复杂性

### 5.2 Spring AI架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用层        │    │   Spring AI     │    │   AI提供商      │
│                 │    │                 │    │                 │
│ • ReviewService │◄──►│ • ChatClient    │◄──►│ • 通义千问      │
│ • PromptTemplate│    │ • PromptEngine  │    │ • OpenAI        │
│ • AIConfig      │    │ • Fallback      │    │ • 其他模型      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 5.3 Spring AI配置

#### 5.3.1 依赖配置
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-core</artifactId>
    <version>1.0.0-M4</version>
</dependency>
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-qwen-spring-boot-starter</artifactId>
    <version>1.0.0-M4</version>
</dependency>
```

#### 5.3.2 配置文件
```yaml
spring:
  ai:
    qwen:
      api-key: ${QWEN_API_KEY}
      base-url: ${QWEN_BASE_URL:https://dashscope.aliyuncs.com/api/v1}
      chat:
        options:
          model: qwen-turbo
          temperature: 0.7
          max-tokens: 2000
```

#### 5.3.3 AI配置类
```java
@Configuration
@EnableAsync
public class AIConfig {
    
    @Bean
    public ChatClient chatClient(
            @Qualifier("qwenChatModel") ChatModel primaryModel,
            @Qualifier("openAIChatModel") ChatModel fallbackModel) {
        
        ChatClient primaryClient = new DefaultChatClient(primaryModel);
        ChatClient fallbackClient = new DefaultChatClient(fallbackModel);
        
        return new FallbackChatClient(primaryClient, fallbackClient);
    }
    
    @Bean
    public PromptTemplateEngine promptTemplateEngine() {
        return new StringTemplateEngine();
    }
    
    @Bean
    public QwenChatModel qwenChatModel(QwenChatProperties properties) {
        return new QwenChatModel(properties);
    }
}
```

### 5.4 提示词模板设计

#### 5.4.1 格式检查提示词模板
```java
@Component
public class FormatCheckPromptTemplate {
    
    private static final String TEMPLATE = """
        你是一个专业的软件文档格式检查专家。请对以下软件概要设计文档进行格式检查：
        
        文档标题：$document_title$
        文档内容：$document_content$
        
        请按照以下维度进行检查：
        1. 标题层级结构是否规范
        2. 图表编号是否连续
        3. 页面格式是否统一
        4. 字体、段落格式是否一致
        5. 目录结构是否完整
        
        请以JSON格式返回检查结果：
        {
            "score": 85.5,
            "status": "PASS|FAIL|NEED_REVIEW",
            "issues": [
                {
                    "type": "FORMAT",
                    "severity": "HIGH|MEDIUM|LOW",
                    "title": "问题标题",
                    "description": "详细描述",
                    "suggestion": "改进建议",
                    "pageNumber": 页码,
                    "lineNumber": 行号
                }
            ],
            "summary": "格式检查总结"
        }
        """;
    
    public String format(String documentTitle, String documentContent) {
        return TEMPLATE
            .replace("$document_title$", documentTitle)
            .replace("$document_content$", documentContent);
    }
}
```

#### 5.4.2 内容评审提示词模板
```java
@Component
public class ContentReviewPromptTemplate {
    
    private static final String TEMPLATE = """
        你是一个资深的软件架构师和文档评审专家。请对以下软件概要设计文档进行深度内容评审：
        
        文档标题：$document_title$
        文档内容：$document_content$
        
        请从以下维度进行评审：
        1. 设计合理性：架构设计是否合理，技术选型是否恰当
        2. 内容完整性：是否包含所有必要的设计要素
        3. 逻辑一致性：各部分内容是否逻辑一致，无矛盾
        4. 技术可行性：技术方案是否具备可实施性
        5. 安全性考虑：是否考虑了安全相关因素
        6. 性能考虑：是否考虑了性能相关因素
        7. 可维护性：设计是否便于后续维护和扩展
        
        请以JSON格式返回评审结果：
        {
            "score": 78.5,
            "status": "PASS|FAIL|NEED_REVIEW",
            "issues": [
                {
                    "type": "CONTENT|LOGIC|COMPLETENESS",
                    "severity": "HIGH|MEDIUM|LOW",
                    "title": "问题标题",
                    "description": "详细描述",
                    "suggestion": "改进建议",
                    "pageNumber": 页码,
                    "lineNumber": 行号
                }
            ],
            "summary": "内容评审总结",
            "strengths": ["优点1", "优点2"],
            "weaknesses": ["不足1", "不足2"],
            "recommendations": ["建议1", "建议2"]
        }
        """;
    
    public String format(String documentTitle, String documentContent) {
        return TEMPLATE
            .replace("$document_title$", documentTitle)
            .replace("$document_content$", documentContent);
    }
}
```

### 5.5 评审服务实现

```java
@Service
@Slf4j
public class ReviewService {
    
    @Autowired
    private ChatClient chatClient;
    
    @Autowired
    private FormatCheckPromptTemplate formatCheckPromptTemplate;
    
    @Autowired
    private ContentReviewPromptTemplate contentReviewPromptTemplate;
    
    @Autowired
    private DocumentService documentService;
    
    @Autowired
    private ReviewResultRepository reviewResultRepository;
    
    @Async
    public CompletableFuture<ReviewResult> processReview(Long reviewId) {
        try {
            // 获取文档内容
            DocumentContent content = documentService.getDocumentContent(reviewId);
            
            // 执行格式检查
            FormatCheckResult formatResult = performFormatCheck(content);
            
            // 执行内容评审
            ContentReviewResult contentResult = performContentReview(content);
            
            // 合并结果
            ReviewResult reviewResult = mergeReviewResults(formatResult, contentResult);
            
            // 保存结果
            reviewResultRepository.save(reviewResult);
            
            return CompletableFuture.completedFuture(reviewResult);
            
        } catch (Exception e) {
            log.error("评审处理失败: reviewId={}", reviewId, e);
            throw new ReviewException("评审处理失败", e);
        }
    }
    
    private FormatCheckResult performFormatCheck(DocumentContent content) {
        try {
            String prompt = formatCheckPromptTemplate.format(
                content.getTitle(), 
                content.getContent()
            );
            
            String response = chatClient.call(prompt);
            return parseFormatCheckResult(response);
            
        } catch (Exception e) {
            log.error("格式检查失败", e);
            return FormatCheckResult.failed("格式检查失败: " + e.getMessage());
        }
    }
    
    private ContentReviewResult performContentReview(DocumentContent content) {
        try {
            String prompt = contentReviewPromptTemplate.format(
                content.getTitle(), 
                content.getContent()
            );
            
            String response = chatClient.call(prompt);
            return parseContentReviewResult(response);
            
        } catch (Exception e) {
            log.error("内容评审失败", e);
            return ContentReviewResult.failed("内容评审失败: " + e.getMessage());
        }
    }
    
    private ReviewResult mergeReviewResults(FormatCheckResult formatResult, 
                                         ContentReviewResult contentResult) {
        // 合并格式检查和内容评审结果
        double overallScore = (formatResult.getScore() + contentResult.getScore()) / 2.0;
        
        ReviewStatus overallStatus = determineOverallStatus(formatResult, contentResult);
        
        List<Issue> allIssues = new ArrayList<>();
        allIssues.addAll(formatResult.getIssues());
        allIssues.addAll(contentResult.getIssues());
        
        return ReviewResult.builder()
            .overallScore(overallScore)
            .overallStatus(overallStatus)
            .formatScore(formatResult.getScore())
            .contentScore(contentResult.getScore())
            .issues(allIssues)
            .aiReviewSummary(contentResult.getSummary())
            .manualReviewRequired(overallStatus == ReviewStatus.NEED_REVIEW)
            .build();
    }
}
```

## 6. 前端页面设计

### 6.1 项目结构
```
frontend/
├── src/
│   ├── components/          # 公共组件
│   │   ├── DocumentUploader.vue
│   │   ├── ReviewResultCard.vue
│   │   └── IssueList.vue
│   ├── views/              # 页面组件
│   │   ├── Dashboard.vue
│   │   ├── DocumentList.vue
│   │   └── ReviewDetail.vue
│   ├── router/             # 路由配置
│   ├── store/              # 状态管理
│   ├── api/                # API接口
│   └── utils/              # 工具函数
├── public/
└── package.json
```

### 6.2 核心组件设计

#### 6.2.1 文档上传组件
```vue
<template>
  <div class="document-uploader">
    <el-upload
      class="upload-dragger"
      drag
      :action="uploadUrl"
      :headers="uploadHeaders"
      :on-success="handleUploadSuccess"
      :on-error="handleUploadError"
      :before-upload="beforeUpload"
      accept=".docx,.pdf"
    >
      <el-icon class="el-icon--upload"><upload-filled /></el-icon>
      <div class="el-upload__text">
        将文件拖到此处，或<em>点击上传</em>
      </div>
      <template #tip>
        <div class="el-upload__tip">
          支持 .docx 和 .pdf 格式，文件大小不超过 50MB
        </div>
      </template>
    </el-upload>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { ElMessage } from 'element-plus'
import { useAuthStore } from '@/store/auth'
import { uploadDocument } from '@/api/document'

const authStore = useAuthStore()

const uploadUrl = computed(() => '/api/v1/documents/upload')
const uploadHeaders = computed(() => ({
  'Authorization': `Bearer ${authStore.token}`
}))

const beforeUpload = (file) => {
  const isValidType = ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/pdf'].includes(file.type)
  const isValidSize = file.size / 1024 / 1024 < 50

  if (!isValidType) {
    ElMessage.error('只支持 .docx 和 .pdf 格式的文件!')
    return false
  }
  if (!isValidSize) {
    ElMessage.error('文件大小不能超过 50MB!')
    return false
  }
  return true
}

const handleUploadSuccess = (response) => {
  if (response.code === 200) {
    ElMessage.success('文档上传成功!')
    // 触发父组件事件
    emit('upload-success', response.data)
  } else {
    ElMessage.error(response.message || '上传失败')
  }
}

const handleUploadError = (error) => {
  ElMessage.error('上传失败: ' + error.message)
}
</script>
```

#### 6.2.2 评审结果卡片组件
```vue
<template>
  <el-card class="review-result-card" shadow="hover">
    <template #header>
      <div class="card-header">
        <span class="document-title">{{ result.documentTitle }}</span>
        <el-tag :type="statusType" size="small">
          {{ statusText }}
        </el-tag>
      </div>
    </template>
    
    <div class="result-content">
      <div class="score-section">
        <div class="overall-score">
          <span class="score-label">总体评分</span>
          <span class="score-value" :class="scoreClass">
            {{ result.overallScore }}
          </span>
        </div>
        <div class="detail-scores">
          <div class="score-item">
            <span>格式评分</span>
            <span>{{ result.formatScore }}</span>
          </div>
          <div class="score-item">
            <span>内容评分</span>
            <span>{{ result.contentScore }}</span>
          </div>
        </div>
      </div>
      
      <div class="summary-section">
        <h4>评审总结</h4>
        <p>{{ result.aiReviewSummary }}</p>
      </div>
      
      <div class="issues-section" v-if="result.issues && result.issues.length > 0">
        <h4>问题清单 ({{ result.issues.length }})</h4>
        <el-collapse>
          <el-collapse-item 
            v-for="issue in result.issues" 
            :key="issue.id"
            :title="`${issue.title} (${issue.severity})`"
          >
            <div class="issue-content">
              <p><strong>描述：</strong>{{ issue.description }}</p>
              <p v-if="issue.suggestion"><strong>建议：</strong>{{ issue.suggestion }}</p>
              <p v-if="issue.pageNumber">
                <strong>位置：</strong>第{{ issue.pageNumber }}页，第{{ issue.lineNumber }}行
              </p>
            </div>
          </el-collapse-item>
        </el-collapse>
      </div>
      
      <div class="actions">
        <el-button 
          type="primary" 
          @click="viewDetail"
          :disabled="result.status !== 'COMPLETED'"
        >
          查看详情
        </el-button>
        <el-button 
          v-if="result.manualReviewRequired"
          type="warning"
          @click="startManualReview"
        >
          人工复核
        </el-button>
      </div>
    </div>
  </el-card>
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'

const props = defineProps({
  result: {
    type: Object,
    required: true
  }
})

const router = useRouter()

const statusType = computed(() => {
  switch (props.result.overallStatus) {
    case 'PASS': return 'success'
    case 'FAIL': return 'danger'
    case 'NEED_REVIEW': return 'warning'
    default: return 'info'
  }
})

const statusText = computed(() => {
  switch (props.result.overallStatus) {
    case 'PASS': return '通过'
    case 'FAIL': return '不通过'
    case 'NEED_REVIEW': return '需复核'
    default: return '未知'
  }
})

const scoreClass = computed(() => {
  const score = props.result.overallScore
  if (score >= 80) return 'score-high'
  if (score >= 60) return 'score-medium'
  return 'score-low'
})

const viewDetail = () => {
  router.push(`/review-detail/${props.result.id}`)
}

const startManualReview = () => {
  router.push(`/manual-review/${props.result.id}`)
}
</script>

<style scoped>
.review-result-card {
  margin-bottom: 20px;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.document-title {
  font-weight: bold;
  font-size: 16px;
}

.score-section {
  margin-bottom: 20px;
}

.overall-score {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding: 10px;
  background-color: #f5f7fa;
  border-radius: 4px;
}

.score-label {
  font-weight: bold;
}

.score-value {
  font-size: 24px;
  font-weight: bold;
}

.score-high { color: #67c23a; }
.score-medium { color: #e6a23c; }
.score-low { color: #f56c6c; }

.detail-scores {
  display: flex;
  justify-content: space-around;
}

.score-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
}

.summary-section, .issues-section {
  margin-bottom: 20px;
}

.issue-content p {
  margin: 5px 0;
}

.actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}
</style>
```

## 7. 部署架构设计

### 7.1 前后端分离部署架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户浏览器    │    │   Nginx         │    │   Docker容器    │
│                 │    │   (反向代理)    │    │                 │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • 访问前端页面  │◄──►│ • 静态文件服务  │    │ • 前端容器      │
│ • 发起API请求   │    │ • API请求代理   │◄──►│ • 后端容器      │
│ • 查看评审结果  │    │ • 负载均衡      │    │ • 数据库容器    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 7.2 Docker部署配置

#### 7.2.1 前端Dockerfile
```dockerfile
# 前端 Dockerfile
FROM node:18-alpine as build-stage

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine as production-stage
COPY --from=build-stage /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### 7.2.2 后端Dockerfile
```dockerfile
# 后端 Dockerfile
FROM openjdk:17-jre-slim

WORKDIR /app
COPY target/arch-ai-review-*.jar app.jar

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### 7.2.3 Docker Compose配置
```yaml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: arch-ai-review-mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: arch_ai_review
      MYSQL_USER: app_user
      MYSQL_PASSWORD: app_password
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: arch-ai-review-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network

  # 后端服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: arch-ai-review-backend
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/arch_ai_review
      SPRING_DATASOURCE_USERNAME: app_user
      SPRING_DATASOURCE_PASSWORD: app_password
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
      QWEN_API_KEY: ${QWEN_API_KEY}
      QWEN_BASE_URL: ${QWEN_BASE_URL}
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
    networks:
      - app-network

  # 前端服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: arch-ai-review-frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network

volumes:
  mysql_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

#### 7.2.4 Nginx配置
```nginx
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;
    
    # 上游后端服务
    upstream backend {
        server backend:8080;
    }
    
    server {
        listen 80;
        server_name localhost;
        
        # 前端静态文件
        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
            
            # 缓存配置
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }
        
        # API请求代理
        location /api/ {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS配置
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization";
            
            # 处理预检请求
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization";
                add_header Access-Control-Max-Age 1728000;
                add_header Content-Type 'text/plain; charset=utf-8';
                add_header Content-Length 0;
                return 204;
            }
        }
        
        # 文件上传大小限制
        client_max_body_size 50M;
    }
}
```

### 7.3 环境变量配置

#### 7.3.1 .env文件
```bash
# 数据库配置
MYSQL_ROOT_PASSWORD=rootpassword
MYSQL_DATABASE=arch_ai_review
MYSQL_USER=app_user
MYSQL_PASSWORD=app_password

# AI服务配置
QWEN_API_KEY=your_qwen_api_key_here
QWEN_BASE_URL=https://dashscope.aliyuncs.com/api/v1

# 应用配置
SPRING_PROFILES_ACTIVE=prod
JWT_SECRET=your_jwt_secret_here
JWT_EXPIRATION=86400
```

### 7.4 部署步骤

1. **环境准备**
   ```bash
   # 安装Docker和Docker Compose
   # 克隆项目代码
   git clone <repository-url>
   cd arch-ai-review
   ```

2. **配置环境变量**
   ```bash
   # 复制环境变量文件
   cp .env.example .env
   # 编辑环境变量
   vim .env
   ```

3. **构建和启动服务**
   ```bash
   # 构建所有服务
   docker-compose build
   
   # 启动所有服务
   docker-compose up -d
   
   # 查看服务状态
   docker-compose ps
   ```

4. **验证部署**
   ```bash
   # 检查服务健康状态
   curl http://localhost/api/health
   
   # 访问前端页面
   open http://localhost
   ```

5. **查看日志**
   ```bash
   # 查看所有服务日志
   docker-compose logs -f
   
   # 查看特定服务日志
   docker-compose logs -f backend
   ```

## 8. 开发计划

### 8.1 开发阶段规划

#### 第一阶段：基础框架搭建 (2周)
- [x] 项目初始化和依赖配置
- [x] 数据库设计和表结构创建
- [x] 基础Spring Boot应用框架
- [x] 用户认证和权限管理
- [x] 基础API接口设计

#### 第二阶段：核心功能开发 (3周)
- [x] 文档解析模块开发
- [x] Spring AI集成和配置
- [x] 格式检查功能实现
- [x] 内容评审功能实现
- [x] 问题管理和报告生成

#### 第三阶段：前端开发 (2周)
- [x] Vue.js项目搭建
- [x] 用户界面设计和实现
- [x] 文档上传和结果展示
- [x] 评审结果详情页面
- [x] 人工复核功能

#### 第四阶段：集成测试 (1周)
- [x] 前后端集成测试
- [x] API接口测试
- [x] 性能测试和优化
- [x] 安全测试

#### 第五阶段：部署和上线 (1周)
- [x] Docker容器化
- [x] 生产环境部署
- [x] 监控和日志配置
- [x] 用户培训和文档

### 8.2 技术难点和解决方案

#### 8.2.1 文档解析准确性
- **难点**：不同格式文档的解析准确性
- **解决方案**：
  - 使用成熟的Apache POI和PDFBox库
  - 实现多种解析策略和降级方案
  - 建立解析结果验证机制

#### 8.2.2 AI评审质量
- **难点**：AI评审结果的准确性和一致性
- **解决方案**：
  - 设计专业的提示词模板
  - 实现多轮评审和结果融合
  - 建立人工复核机制

#### 8.2.3 系统性能
- **难点**：大文档处理和并发访问性能
- **解决方案**：
  - 实现异步处理和任务队列
  - 使用Redis缓存提升响应速度
  - 优化数据库查询和索引

#### 8.2.4 前后端分离
- **难点**：前后端协调开发和部署
- **解决方案**：
  - 使用Docker Compose统一管理
  - 实现API版本控制和向后兼容
  - 建立完善的错误处理机制

## 9. 总结

### 9.1 项目特色

1. **智能化评审**：基于Spring AI集成大模型能力，提供智能化的文档评审服务
2. **前后端分离**：采用现代化的前后端分离架构，便于独立开发和部署
3. **容器化部署**：使用Docker实现一键部署，简化运维管理
4. **可扩展设计**：模块化设计支持功能扩展和性能优化
5. **用户友好**：提供直观的用户界面和便捷的操作体验

### 9.2 技术优势

1. **Spring AI集成**：统一管理多种AI服务，简化AI集成复杂度
2. **Vue.js 3.x**：使用最新的Vue.js框架，提供更好的开发体验
3. **Spring Boot 3.5.x**：采用最新的Spring Boot版本，享受最新特性
4. **MySQL 8.0**：使用高性能的MySQL数据库，支持复杂查询
5. **Docker容器化**：实现环境一致性，简化部署和运维

### 9.3 应用价值

1. **提升效率**：自动化评审流程，大幅提升文档评审效率
2. **保证质量**：基于AI的智能分析，确保评审结果的客观性和准确性
3. **降低成本**：减少人工评审工作量，降低项目成本
4. **标准化**：建立统一的评审标准和流程，提高文档质量
5. **可追溯**：完整的评审记录和问题跟踪，便于后续改进

### 9.4 未来展望

1. **功能扩展**：支持更多文档格式和评审维度
2. **AI优化**：持续优化AI模型和提示词，提升评审质量
3. **性能提升**：优化系统架构，支持更大规模的并发访问
4. **集成能力**：与更多开发工具和平台集成，形成完整的开发工具链
5. **智能化升级**：引入更多AI能力，实现更智能的文档分析和建议

通过本项目的实施，将建立一个高效、智能、易用的软件概要设计文档评审工具，为软件开发团队提供强有力的质量保障支持。
